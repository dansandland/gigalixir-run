#!/bin/bash
# Assumes $APP_KEY is available
# Assumes $MY_POD_IP is available
# Assumes $ERLANG_COOKIE is available
set -exuo pipefail

REPO=$1
APP=$2
CMD="${@:3}"

# HACK ALERT 
# Save important env variables for observer and run-cmd when it SSHes in.
# Normally these variables are set by the pod spec and injected by kubernetes, but 
# if you SSH into the container manually, they are not set.
# On container startup, we save these variables to the filesystem for use later when
# you SSH in.
mkdir -p /kube-env-vars
echo $MY_POD_IP > /kube-env-vars/MY_POD_IP
echo $ERLANG_COOKIE > /kube-env-vars/ERLANG_COOKIE
echo $REPO > /kube-env-vars/REPO
echo $APP > /kube-env-vars/APP

# Upstart, systemd, etc do not run in docker containers, nor do I want them to. 
# We start the ssh server manually on init. This is not an ideal solution, but
# is a fine place to start. If the SSH server dies it won't respawn, but I think
# that is okay for now.
# SSH is needed for observer and remote_console.
# Cron is needed to update ssh keys>
service ssh start

mkdir -p /root/.ssh

# I can't bake this into the image because the env vars are not available at build time. We set it up here
# at container startup.
UPDATE_AUTHORIZED_KEYS_CMD="curl https://api.gigalixir.com/api/apps/$REPO/ssh_keys -u $REPO:$APP_KEY | jq -r '.data | .[]' > /root/.ssh/authorized_keys"
/bin/bash -c "$UPDATE_AUTHORIZED_KEYS_CMD"
echo "* * * * * $UPDATE_AUTHORIZED_KEYS_CMD && echo \$(date) >> /var/log/cron.log" | crontab
cron

pushd /app
CURRENT=$(curl https://api.gigalixir.com/api/apps/$REPO/releases/current -u $REPO:$APP_KEY | jq -r '.data.slug_url')
curl -o $APP.tar.gz "$CURRENT"
tar zxvf $APP.tar.gz

# Put epmd on the path for observer.
find /app -name epmd -exec ln -s '{}' /usr/local/bin/epmd \;

pushd $(dirname $0)
./run-cmd "$CMD"
